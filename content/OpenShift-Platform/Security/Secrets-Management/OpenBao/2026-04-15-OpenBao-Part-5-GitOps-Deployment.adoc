--- 
title: "The Guide to OpenBao - GitOps Deployment with Argo CD - Part 5"
description: "Deploying and managing OpenBao using GitOps principles with Argo CD for declarative, version-controlled secret management infrastructure"
date: "2026-04-15"
doctype: book
weight: 96

series: "The Guide to OpenBao"
series_part: 5

featured_image: /openshift-platform/security/secrets-management/openbao/images/Logo_OpenBao.png
show_featured_image_summary: true
show_featured_image_article: true
disableBreadcrumb: true

authors: [Thomas Jungbauer]
type: post
draft: true
categories:
   - OpenShift
   - Security
   - Secret Management
   - GitOps

tags: ["OCP", "Day-2", "OpenShift", "OpenBao", "Vault", "Secrets", "Security", "GitOps", "Argo CD"] 

aliases: [ 
	 "/openshift/security/openbao/2026-02-15-openbao-gitops-deployment/",
]
---

:imagesdir: /openshift-platform/security/secrets-management/openbao/images/
:icons: font
:toc:

Following the GitOps mantra "If it is not in Git, it does not exist", this article demonstrates how to deploy and manage OpenBao using Argo CD. This approach provides version control, audit trails, and declarative management for your secret management infrastructure.

<!--more--> 

== Introduction

Deploying OpenBao via GitOps offers significant advantages:

* **Version Control**: All configuration changes are tracked in Git
* **Audit Trail**: Who changed what, when, and why
* **Declarative**: Desired state is defined, not imperative commands
* **Reproducible**: Same deployment process across environments
* **Self-healing**: Argo CD ensures actual state matches desired state

However, there are challenges specific to secret management:

* Initial unsealing requires manual intervention or automation
* Root tokens and unseal keys must be handled carefully
* Chicken-and-egg problem: How to store OpenBao secrets before OpenBao exists?

This article addresses these challenges with practical solutions.

== Prerequisites

Before proceeding, ensure you have:

* OpenShift GitOps (Argo CD) installed and configured
* A Git repository for your cluster configuration
* Understanding of the App-of-Apps pattern (see link:/gitopscollection/2024-04-02-configure_app_of_apps/[Configure App-of-Apps^])
* The Helm chart from Part 3

== Repository Structure

Organize your Git repository to include OpenBao:

[source]
----
clusters/
├── management-cluster/
│   └── cluster-config/
│       ├── values-global.yaml
│       └── values-openbao.yaml
└── tenants/
    ├── openbao/
    │   ├── Chart.yaml
    │   ├── values.yaml
    │   └── templates/
    │       ├── namespace.yaml
    │       ├── application-openbao.yaml
    │       └── openbao-route.yaml
    └── ...
----

== Creating the OpenBao Application

=== Step 1: Namespace Configuration

Create `tenants/openbao/templates/namespace.yaml`:

[source,yaml]
----
apiVersion: v1
kind: Namespace
metadata:
  name: openbao
  labels:
    argocd.argoproj.io/managed-by: openshift-gitops
    openshift.io/cluster-monitoring: "true"
  annotations:
    openshift.io/description: "OpenBao Secret Management System"
----

=== Step 2: Helm Values for OpenBao

Create `tenants/openbao/values.yaml`:

[source,yaml]
----
# OpenBao GitOps Deployment Values

openbao:
  # Enable OpenBao deployment
  enabled: true
  
  # Helm chart source
  chart:
    repoURL: https://openbao.github.io/openbao-helm
    chart: openbao
    targetRevision: "0.5.0"  # Pin to specific version
  
  # Namespace for OpenBao
  namespace: openbao
  
  # Sync policy
  syncPolicy:
    automated:
      prune: false  # Don't auto-delete OpenBao resources
      selfHeal: true
    syncOptions:
      - CreateNamespace=false
      - ServerSideApply=true
  
  # Helm values passed to OpenBao chart
  values:
    global:
      openshift: true
    
    server:
      ha:
        enabled: true
        replicas: 3
        raft:
          enabled: true
          setNodeId: true
          config: |
            ui = true
            
            listener "tcp" {
              tls_disable = 1
              address = "[::]:8200"
              cluster_address = "[::]:8201"
              telemetry {
                unauthenticated_metrics_access = "true"
              }
            }
            
            storage "raft" {
              path = "/openbao/data"
              retry_join {
                leader_api_addr = "http://openbao-0.openbao-internal:8200"
              }
              retry_join {
                leader_api_addr = "http://openbao-1.openbao-internal:8200"
              }
              retry_join {
                leader_api_addr = "http://openbao-2.openbao-internal:8200"
              }
            }
            
            service_registration "kubernetes" {}
            
            telemetry {
              prometheus_retention_time = "30s"
              disable_hostname = true
            }
      
      resources:
        requests:
          memory: 256Mi
          cpu: 250m
        limits:
          memory: 1Gi
          cpu: 1000m
      
      dataStorage:
        enabled: true
        size: 10Gi
      
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchLabels:
                  app.kubernetes.io/name: openbao
                  component: server
              topologyKey: kubernetes.io/hostname
      
      readinessProbe:
        enabled: true
        path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"
      
      livenessProbe:
        enabled: true
        path: "/v1/sys/health?standbyok=true"
        initialDelaySeconds: 60
    
    injector:
      enabled: true
      replicas: 2
      resources:
        requests:
          memory: 64Mi
          cpu: 50m
        limits:
          memory: 256Mi
          cpu: 250m
    
    ui:
      enabled: true
      serviceType: ClusterIP

# Route configuration
route:
  enabled: true
  host: openbao.apps.cluster.example.com
  tls:
    termination: edge
----

=== Step 3: Argo CD Application Template

Create `tenants/openbao/templates/application-openbao.yaml`:

[source,yaml]
----
{{- if .Values.openbao.enabled }}
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: openbao
  namespace: openshift-gitops
  labels:
    app.kubernetes.io/name: openbao
    app.kubernetes.io/component: secret-management
  annotations:
    argocd.argoproj.io/sync-wave: "10"
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  
  source:
    repoURL: {{ .Values.openbao.chart.repoURL }}
    chart: {{ .Values.openbao.chart.chart }}
    targetRevision: {{ .Values.openbao.chart.targetRevision }}
    helm:
      releaseName: openbao
      values: |
        {{- .Values.openbao.values | toYaml | nindent 8 }}
  
  destination:
    server: https://kubernetes.default.svc
    namespace: {{ .Values.openbao.namespace }}
  
  syncPolicy:
    {{- .Values.openbao.syncPolicy | toYaml | nindent 4 }}
{{- end }}
----

=== Step 4: Route Template

Create `tenants/openbao/templates/openbao-route.yaml`:

[source,yaml]
----
{{- if and .Values.openbao.enabled .Values.route.enabled }}
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: openbao
  namespace: {{ .Values.openbao.namespace }}
  labels:
    app.kubernetes.io/name: openbao
  annotations:
    argocd.argoproj.io/sync-wave: "20"
spec:
  host: {{ .Values.route.host }}
  port:
    targetPort: 8200
  tls:
    termination: {{ .Values.route.tls.termination }}
    insecureEdgeTerminationPolicy: Redirect
  to:
    kind: Service
    name: openbao
    weight: 100
{{- end }}
----

=== Step 5: Chart.yaml

Create `tenants/openbao/Chart.yaml`:

[source,yaml]
----
apiVersion: v2
name: openbao-deployment
description: GitOps deployment of OpenBao secret management
type: application
version: 1.0.0
appVersion: "2.0.0"
----

== Integrating with App-of-Apps

If you are using the App-of-Apps pattern, add OpenBao to your ApplicationSet:

[source,yaml]
----
# In your cluster configuration values file
applications:
  openbao:
    enabled: true
    path: tenants/openbao
    namespace: openbao
    syncWave: 10
    ignoreDifferences:
      - group: ""
        kind: Secret
        jsonPointers:
          - /data
----

Or create a direct Application:

[source,yaml]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: openbao-deployment
  namespace: openshift-gitops
spec:
  project: default
  source:
    repoURL: https://github.com/your-org/cluster-config.git
    targetRevision: main
    path: tenants/openbao
  destination:
    server: https://kubernetes.default.svc
    namespace: openbao
  syncPolicy:
    automated:
      selfHeal: true
----

== Handling Initialization

The challenge with GitOps deployment is that OpenBao needs to be initialized and unsealed before it becomes functional. Here are several approaches:

=== Approach 1: Manual Initialization (Simplest)

After Argo CD deploys OpenBao:

[source,bash]
----
# Wait for pods to be running
oc get pods -n openbao -w

# Initialize
oc exec -it openbao-0 -n openbao -- bao operator init \
  -key-shares=5 -key-threshold=3 -format=json > openbao-init.json

# Unseal each pod (3 times each with different keys)
for i in 0 1 2; do
  echo "Unsealing openbao-$i..."
  for j in 1 2 3; do
    KEY=$(cat openbao-init.json | jq -r ".unseal_keys_b64[$((j-1))]")
    oc exec -it openbao-$i -n openbao -- bao operator unseal $KEY
  done
done

# Store init data securely (e.g., in a password manager)
----

=== Approach 2: Init Container with External Secret Store

Use an init container that retrieves unseal keys from an external source:

[source,yaml]
----
# Additional values for the Helm chart
server:
  extraInitContainers:
    - name: auto-unseal
      image: registry.access.redhat.com/ubi9/ubi-minimal:latest
      command:
        - /bin/sh
        - -c
        - |
          # Fetch unseal keys from external secret manager
          # This is a placeholder - implement based on your setup
          echo "Waiting for OpenBao to be ready..."
          sleep 30
          # Your unseal logic here
      env:
        - name: EXTERNAL_SECRET_ENDPOINT
          value: "https://your-external-secret-store.example.com"
----

=== Approach 3: Kubernetes Job for Initialization

Create a Job that runs after OpenBao deployment:

[source,yaml]
----
apiVersion: batch/v1
kind: Job
metadata:
  name: openbao-init
  namespace: openbao
  annotations:
    argocd.argoproj.io/sync-wave: "30"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  template:
    spec:
      serviceAccountName: openbao-init
      containers:
        - name: init
          image: ghcr.io/openbao/openbao:latest
          command:
            - /bin/sh
            - -c
            - |
              export BAO_ADDR=http://openbao:8200
              
              # Wait for OpenBao to be ready
              until bao status 2>&1 | grep -q "Initialized"; do
                echo "Waiting for OpenBao..."
                sleep 5
              done
              
              # Check if already initialized
              if bao status | grep -q "Initialized.*false"; then
                echo "Initializing OpenBao..."
                bao operator init -key-shares=5 -key-threshold=3 \
                  -format=json > /tmp/init.json
                
                # Store init data in a Kubernetes secret
                kubectl create secret generic openbao-init-data \
                  --from-file=init.json=/tmp/init.json \
                  -n openbao
                
                echo "Initialization complete!"
              else
                echo "OpenBao already initialized"
              fi
      restartPolicy: Never
  backoffLimit: 3
----

=== Approach 4: Auto-Unseal with KMS (Recommended for Production)

Configure auto-unseal to eliminate manual unsealing. This is covered in detail in Part 9.

[source,yaml]
----
# Example with AWS KMS
server:
  ha:
    raft:
      config: |
        seal "awskms" {
          region     = "us-east-1"
          kms_key_id = "alias/openbao-unseal-key"
        }
        
        # ... rest of config
----

== Multi-Cluster Deployment with ApplicationSet

For deploying OpenBao across multiple clusters:

[source,yaml]
----
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: openbao-multi-cluster
  namespace: openshift-gitops
spec:
  generators:
    - clusters:
        selector:
          matchLabels:
            openbao-enabled: "true"
  template:
    metadata:
      name: 'openbao-{{name}}'
    spec:
      project: default
      source:
        repoURL: https://github.com/your-org/cluster-config.git
        targetRevision: main
        path: tenants/openbao
        helm:
          valueFiles:
            - 'values-{{name}}.yaml'
      destination:
        server: '{{server}}'
        namespace: openbao
      syncPolicy:
        automated:
          selfHeal: true
----

== Handling Sensitive Configuration

Some OpenBao configurations contain sensitive data. Handle these carefully:

=== Using Sealed Secrets for Pre-OpenBao Secrets

Before OpenBao is available, use Sealed Secrets for bootstrap secrets:

[source,yaml]
----
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: openbao-license
  namespace: openbao
  annotations:
    argocd.argoproj.io/sync-wave: "5"
spec:
  encryptedData:
    license: AgBYw...encrypted...data==
----

=== Using External Secrets Operator

If you have another secret backend available:

[source,yaml]
----
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: openbao-config-secrets
  namespace: openbao
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: existing-secret-backend
  target:
    name: openbao-config-secrets
  data:
    - secretKey: kms-credentials
      remoteRef:
        key: openbao/kms-credentials
----

== Sync Waves and Dependencies

Use sync waves to ensure proper deployment order:

[source]
----
Wave 5:  Namespace, ServiceAccount, Sealed Secrets (bootstrap)
Wave 10: OpenBao Helm Release (main deployment)
Wave 20: Route, NetworkPolicies
Wave 30: Initialization Job (if using automated init)
Wave 40: Post-configuration (policies, auth methods)
----

Example sync wave annotations:

[source,yaml]
----
# Namespace first
metadata:
  annotations:
    argocd.argoproj.io/sync-wave: "5"

# OpenBao deployment
metadata:
  annotations:
    argocd.argoproj.io/sync-wave: "10"

# Route after OpenBao is up
metadata:
  annotations:
    argocd.argoproj.io/sync-wave: "20"
----

== Monitoring Deployment Status

Track the OpenBao deployment in Argo CD:

[source,bash]
----
# Check application status
argocd app get openbao

# Watch sync status
argocd app wait openbao --health

# Check OpenBao pods
oc get pods -n openbao

# Verify OpenBao is functional
oc exec -it openbao-0 -n openbao -- bao status
----

== Ignoring Expected Differences

Some resources will have expected differences. Configure Argo CD to ignore them:

[source,yaml]
----
spec:
  ignoreDifferences:
    # Ignore seal status differences (expected)
    - group: ""
      kind: Pod
      jsonPointers:
        - /status
    
    # Ignore auto-generated secrets
    - group: ""
      kind: Secret
      name: openbao-init-data
      jsonPointers:
        - /data
----

== What is Coming Next?

In Part 6, we will configure authentication methods for OpenBao:

* Kubernetes authentication for pods
* OIDC for user access
* AppRole for CI/CD systems
* Policies and role bindings

== Conclusion

Deploying OpenBao via GitOps provides the benefits of version control and declarative management for your secret management infrastructure. While initialization and unsealing require special handling, the approaches outlined here enable fully automated or semi-automated deployments.

Key takeaways:

* Pin Helm chart versions for reproducibility
* Use sync waves for proper deployment order
* Handle initialization with Jobs or manual processes
* Consider auto-unseal for production (Part 9)
* Store init data securely outside of Git

== Resources

* link:/gitopscollection/2024-04-02-configure_app_of_apps/[Configure App-of-Apps^]
* https://argo-cd.readthedocs.io/en/stable/user-guide/helm/[Argo CD Helm Support^]
* https://argo-cd.readthedocs.io/en/stable/user-guide/sync-waves/[Argo CD Sync Waves^]
