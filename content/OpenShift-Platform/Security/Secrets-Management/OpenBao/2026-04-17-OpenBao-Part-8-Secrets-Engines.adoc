--- 
title: "The Guide to OpenBao - Secrets Engines - Part 8"
description: "Deep dive into OpenBao secrets engines: KV for static secrets, PKI for certificates, Database for dynamic credentials, and Transit for encryption"
date: "2026-04-17"
doctype: book
weight: 93

series: "The Guide to OpenBao"
series_part: 8

featured_image: /openshift-platform/security/secrets-management/openbao/images/Logo_OpenBao.png
show_featured_image_summary: true
show_featured_image_article: true
disableBreadcrumb: true

authors: [Thomas Jungbauer]
type: post
draft: true
categories:
   - OpenShift
   - Security
   - Secret Management

tags: ["OCP", "Day-2", "OpenShift", "OpenBao", "Vault", "Secrets", "Security", "PKI", "Encryption", "Database"] 

aliases: [ 
	 "/openshift/security/openbao/2026-02-13-openbao-secrets-engines/",
]
---

:imagesdir: /openshift-platform/security/secrets-management/openbao/images/
:icons: font
:toc:

Secrets engines are the heart of OpenBao's functionality. They store, generate, or encrypt data. This article covers the most commonly used secrets engines: KV for static secrets, PKI for certificate management, Database for dynamic credentials, and Transit for encryption as a service.

<!--more--> 

== Introduction

OpenBao secrets engines are components that:

* **Store secrets** (KV engine)
* **Generate secrets** (PKI, Database engines)
* **Encrypt data** (Transit engine)
* **Generate OTPs** (TOTP engine)

Each engine is enabled at a specific path and operates independently.

[source,bash]
----
# List enabled secrets engines
bao secrets list

# Default output:
# Path          Type         Description
# ----          ----         -----------
# cubbyhole/    cubbyhole    per-token private secret storage
# identity/     identity     identity store
# sys/          system       system endpoints
----

== KV (Key-Value) Secrets Engine

The KV engine stores arbitrary static secrets. It is the most commonly used engine.

=== KV Version 1 vs Version 2

[cols="1,2,2"]
|===
|Feature |Version 1 |Version 2

|Versioning
|No
|Yes (up to 10 versions by default)

|Check-and-Set
|No
|Yes (prevents concurrent writes)

|Soft delete
|No
|Yes (recoverable)

|Metadata
|No
|Yes (custom metadata)
|===

=== Enabling KV Engine

[source,bash]
----
# Enable KV v2 at a custom path
bao secrets enable -path=secret -version=2 kv

# Or with description
bao secrets enable \
  -path=apps \
  -version=2 \
  -description="Application secrets" \
  kv
----

=== Storing Secrets

[source,bash]
----
# Put a secret (KV v2)
bao kv put secret/myapp/database \
  username="dbadmin" \
  password="supersecret123" \
  host="db.example.com" \
  port="5432"

# Put from file
cat > /tmp/config.json <<EOF
{
  "api_key": "abc123",
  "api_secret": "xyz789",
  "endpoint": "https://api.example.com"
}
EOF

bao kv put secret/myapp/api @/tmp/config.json
----

=== Reading Secrets

[source,bash]
----
# Read a secret
bao kv get secret/myapp/database

# Get specific field
bao kv get -field=password secret/myapp/database

# Get as JSON
bao kv get -format=json secret/myapp/database

# Read specific version
bao kv get -version=2 secret/myapp/database
----

=== Managing Versions

[source,bash]
----
# List all versions
bao kv metadata get secret/myapp/database

# Delete specific version (soft delete)
bao kv delete -versions=2 secret/myapp/database

# Undelete a version
bao kv undelete -versions=2 secret/myapp/database

# Permanently destroy a version
bao kv destroy -versions=2 secret/myapp/database

# Delete all versions and metadata
bao kv metadata delete secret/myapp/database
----

=== Custom Metadata

[source,bash]
----
# Add custom metadata to a secret
bao kv metadata put \
  -custom-metadata="owner=team-a" \
  -custom-metadata="environment=production" \
  -max-versions=5 \
  secret/myapp/database
----

=== Policies for KV v2

[source,hcl]
----
# Note: KV v2 uses /data/ for values and /metadata/ for metadata

# Read secret values
path "secret/data/myapp/*" {
  capabilities = ["read"]
}

# List secrets
path "secret/metadata/myapp/*" {
  capabilities = ["list"]
}

# Full access to specific path
path "secret/data/myapp/database" {
  capabilities = ["create", "read", "update", "delete"]
}

path "secret/metadata/myapp/database" {
  capabilities = ["read", "list", "delete"]
}
----

== PKI Secrets Engine

The PKI engine generates X.509 certificates, acting as a Certificate Authority.

=== Setting Up a Root CA

[source,bash]
----
# Enable PKI engine for root CA
bao secrets enable -path=pki pki

# Configure maximum lease time
bao secrets tune -max-lease-ttl=87600h pki

# Generate root certificate
bao write pki/root/generate/internal \
  common_name="Example Root CA" \
  issuer_name="root-ca" \
  ttl=87600h \
  key_bits=4096

# Configure CA and CRL URLs
bao write pki/config/urls \
  issuing_certificates="https://openbao.example.com/v1/pki/ca" \
  crl_distribution_points="https://openbao.example.com/v1/pki/crl"
----

=== Setting Up an Intermediate CA

For production, use an intermediate CA:

[source,bash]
----
# Enable PKI engine for intermediate CA
bao secrets enable -path=pki_int pki

# Configure maximum lease time
bao secrets tune -max-lease-ttl=43800h pki_int

# Generate intermediate CSR
bao write -format=json pki_int/intermediate/generate/internal \
  common_name="Example Intermediate CA" \
  issuer_name="intermediate-ca" \
  key_bits=4096 \
  | jq -r '.data.csr' > /tmp/pki_int.csr

# Sign the intermediate with root CA
bao write -format=json pki/root/sign-intermediate \
  csr=@/tmp/pki_int.csr \
  format=pem_bundle \
  ttl=43800h \
  | jq -r '.data.certificate' > /tmp/intermediate.cert.pem

# Set the signed certificate
bao write pki_int/intermediate/set-signed \
  certificate=@/tmp/intermediate.cert.pem
----

=== Creating Certificate Roles

[source,bash]
----
# Create a role for issuing server certificates
bao write pki_int/roles/server-cert \
  allowed_domains="example.com,internal.example.com" \
  allow_subdomains=true \
  max_ttl=720h \
  key_bits=2048 \
  key_type=rsa \
  require_cn=false \
  allow_any_name=false

# Create a role for client certificates
bao write pki_int/roles/client-cert \
  allowed_domains="example.com" \
  allow_subdomains=true \
  max_ttl=168h \
  key_usage="DigitalSignature,KeyEncipherment" \
  ext_key_usage="ClientAuth"
----

=== Issuing Certificates

[source,bash]
----
# Issue a server certificate
bao write pki_int/issue/server-cert \
  common_name="myapp.example.com" \
  alt_names="myapp.internal.example.com" \
  ttl=168h

# Output includes:
# - certificate
# - issuing_ca
# - private_key
# - serial_number

# Issue with JSON output for automation
bao write -format=json pki_int/issue/server-cert \
  common_name="api.example.com" \
  ttl=168h > /tmp/api-cert.json

# Extract components
cat /tmp/api-cert.json | jq -r '.data.certificate' > api.crt
cat /tmp/api-cert.json | jq -r '.data.private_key' > api.key
cat /tmp/api-cert.json | jq -r '.data.ca_chain[]' > ca-chain.crt
----

=== PKI Policies

[source,hcl]
----
# Allow issuing certificates with the server-cert role
path "pki_int/issue/server-cert" {
  capabilities = ["create", "update"]
}

# Allow reading CA certificate
path "pki_int/ca/pem" {
  capabilities = ["read"]
}

# Allow reading CRL
path "pki_int/crl/pem" {
  capabilities = ["read"]
}
----

=== Integration with cert-manager

OpenBao PKI integrates with cert-manager via the Vault issuer:

[source,yaml]
----
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: openbao-issuer
  namespace: myapp
spec:
  vault:
    path: pki_int/sign/server-cert
    server: https://openbao.openbao:8200
    auth:
      kubernetes:
        role: cert-manager
        mountPath: /v1/auth/kubernetes
        serviceAccountRef:
          name: cert-manager
----

== Database Secrets Engine

The Database engine generates dynamic, short-lived database credentials.

=== Supported Databases

OpenBao supports multiple databases:

* PostgreSQL
* MySQL/MariaDB
* MongoDB
* Microsoft SQL Server
* Oracle
* And more...

=== Setting Up PostgreSQL Dynamic Secrets

==== Step 1: Enable Database Engine

[source,bash]
----
bao secrets enable -path=database database
----

==== Step 2: Configure Database Connection

[source,bash]
----
bao write database/config/myapp-db \
  plugin_name=postgresql-database-plugin \
  allowed_roles="myapp-readonly,myapp-readwrite" \
  connection_url="postgresql://{{username}}:{{password}}@db.example.com:5432/myapp?sslmode=require" \
  username="openbao_admin" \
  password="initial_password" \
  password_authentication="scram-sha-256"
----

==== Step 3: Rotate Root Credentials

[source,bash]
----
# Rotate the root password (OpenBao manages it from now)
bao write -force database/rotate-root/myapp-db
----

==== Step 4: Create Database Roles

[source,bash]
----
# Read-only role
bao write database/roles/myapp-readonly \
  db_name=myapp-db \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
    GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
  revocation_statements="DROP ROLE IF EXISTS \"{{name}}\";" \
  default_ttl="1h" \
  max_ttl="24h"

# Read-write role
bao write database/roles/myapp-readwrite \
  db_name=myapp-db \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
  revocation_statements="DROP ROLE IF EXISTS \"{{name}}\";" \
  default_ttl="1h" \
  max_ttl="8h"
----

==== Step 5: Generate Credentials

[source,bash]
----
# Request read-only credentials
bao read database/creds/myapp-readonly

# Output:
# Key                Value
# ---                -----
# lease_id           database/creds/myapp-readonly/xxx
# lease_duration     1h
# username           v-token-myapp-r-xxx
# password           xxx

# Request read-write credentials
bao read database/creds/myapp-readwrite
----

=== Database Policies

[source,hcl]
----
# Allow generating read-only credentials
path "database/creds/myapp-readonly" {
  capabilities = ["read"]
}

# Allow renewing leases
path "sys/leases/renew" {
  capabilities = ["update"]
}
----

=== MySQL Configuration Example

[source,bash]
----
bao write database/config/mysql-db \
  plugin_name=mysql-database-plugin \
  allowed_roles="mysql-readonly" \
  connection_url="{{username}}:{{password}}@tcp(mysql.example.com:3306)/" \
  username="openbao" \
  password="initial_password"

bao write database/roles/mysql-readonly \
  db_name=mysql-db \
  creation_statements="CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}'; \
    GRANT SELECT ON mydb.* TO '{{name}}'@'%';" \
  revocation_statements="DROP USER IF EXISTS '{{name}}'@'%';" \
  default_ttl="1h"
----

== Transit Secrets Engine

The Transit engine provides encryption as a service (EaaS) without storing the data.

=== Enabling Transit Engine

[source,bash]
----
bao secrets enable transit
----

=== Creating Encryption Keys

[source,bash]
----
# Create an AES-256-GCM key (default)
bao write -f transit/keys/myapp-key

# Create with specific type
bao write transit/keys/rsa-key \
  type=rsa-4096

# Create with auto-rotation
bao write transit/keys/auto-rotate-key \
  auto_rotate_period=30d
----

=== Encrypting Data

[source,bash]
----
# Encrypt plaintext (must be base64 encoded)
PLAINTEXT=$(echo -n "my secret data" | base64)
bao write transit/encrypt/myapp-key \
  plaintext="$PLAINTEXT"

# Output:
# Key           Value
# ciphertext    vault:v1:xxx...

# Encrypt with JSON output
bao write -format=json transit/encrypt/myapp-key \
  plaintext="$PLAINTEXT" \
  | jq -r '.data.ciphertext'
----

=== Decrypting Data

[source,bash]
----
# Decrypt ciphertext
bao write -format=json transit/decrypt/myapp-key \
  ciphertext="vault:v1:xxx..." \
  | jq -r '.data.plaintext' \
  | base64 -d
----

=== Batch Operations

[source,bash]
----
# Encrypt multiple items
bao write transit/encrypt/myapp-key \
  batch_input='[
    {"plaintext": "'$(echo -n "secret1" | base64)'"},
    {"plaintext": "'$(echo -n "secret2" | base64)'"}
  ]'
----

=== Key Rotation

[source,bash]
----
# Rotate the encryption key
bao write -f transit/keys/myapp-key/rotate

# Old ciphertext can still be decrypted (key versions are maintained)

# Re-encrypt old ciphertext with new key version
bao write transit/rewrap/myapp-key \
  ciphertext="vault:v1:xxx..."

# Output uses new key version: vault:v2:yyy...
----

=== Data Signing

[source,bash]
----
# Create a signing key
bao write transit/keys/signing-key \
  type=ecdsa-p256

# Sign data
DATA=$(echo -n "data to sign" | base64)
bao write transit/sign/signing-key \
  input="$DATA"

# Verify signature
bao write transit/verify/signing-key \
  input="$DATA" \
  signature="vault:v1:xxx..."
----

=== Transit Policies

[source,hcl]
----
# Allow encryption only
path "transit/encrypt/myapp-key" {
  capabilities = ["update"]
}

# Allow decryption only
path "transit/decrypt/myapp-key" {
  capabilities = ["update"]
}

# Allow both
path "transit/+/myapp-key" {
  capabilities = ["update"]
}

# Allow signing but not decryption
path "transit/sign/signing-key" {
  capabilities = ["update"]
}

path "transit/verify/signing-key" {
  capabilities = ["update"]
}
----

== Organizing Secrets with Mount Paths

Use descriptive mount paths to organize secrets engines:

[source,bash]
----
# Per-environment secrets
bao secrets enable -path=prod/secrets kv-v2
bao secrets enable -path=staging/secrets kv-v2
bao secrets enable -path=dev/secrets kv-v2

# Per-team secrets
bao secrets enable -path=team-a/secrets kv-v2
bao secrets enable -path=team-b/secrets kv-v2

# Functional organization
bao secrets enable -path=database database
bao secrets enable -path=pki pki
bao secrets enable -path=encryption transit
----

== Lease Management

Many secrets have leases that expire:

[source,bash]
----
# List leases
bao list sys/leases/lookup/database/creds/myapp-readonly

# Lookup specific lease
bao lease lookup database/creds/myapp-readonly/xxx

# Renew a lease
bao lease renew database/creds/myapp-readonly/xxx

# Renew with specific duration
bao lease renew -increment=3600 database/creds/myapp-readonly/xxx

# Revoke a lease
bao lease revoke database/creds/myapp-readonly/xxx

# Revoke all leases under a path
bao lease revoke -prefix database/creds/myapp-readonly
----

== What is Coming Next?

In Part 9, we will explore how Kubernetes workloads consume secrets:

* Agent Injector (sidecar injection)
* CSI Provider (volume mounts)
* External Secrets Operator (sync to K8s Secrets)

== Conclusion

Secrets engines are the core functionality of OpenBao:

* **KV**: Static secrets with versioning
* **PKI**: Certificate Authority capabilities
* **Database**: Dynamic, short-lived credentials
* **Transit**: Encryption without storing data

Key takeaways:

* Use KV v2 for versioning and soft delete
* Use intermediate CAs in PKI for security
* Dynamic database credentials reduce blast radius
* Transit offloads encryption complexity

== Resources

* https://openbao.org/docs/secrets/kv/kv-v2[KV Secrets Engine v2^]
* https://openbao.org/docs/secrets/pki[PKI Secrets Engine^]
* https://openbao.org/docs/secrets/databases[Database Secrets Engine^]
* https://openbao.org/docs/secrets/transit[Transit Secrets Engine^]
