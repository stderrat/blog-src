<!-- Code Block Language Badges -->
<script>
(function() {
    // Add language badges to code blocks - positioned as tabs above the code block
    document.querySelectorAll('pre code[class*="language-"], pre code[class*="hljs"]').forEach(function(codeBlock) {
        // Get the language from class
        let language = null;
        const classes = codeBlock.className.split(' ');
        
        for (const cls of classes) {
            // Check for language-xxx patterns
            if (cls.startsWith('language-')) {
                language = cls.replace('language-', '');
                break;
            }
            // Also check for direct language class (e.g., 'yaml', 'bash')
            const knownLanguages = ['yaml', 'yml', 'bash', 'shell', 'sh', 'javascript', 'js', 'typescript', 'ts', 
                'python', 'py', 'go', 'golang', 'json', 'html', 'css', 'dockerfile', 'docker', 'ruby', 'rb', 
                'java', 'sql', 'xml', 'markdown', 'md', 'rust', 'rs', 'terraform', 'tf', 'hcl', 'ansible', 'helm',
                'c', 'cpp', 'csharp', 'php', 'perl', 'lua', 'r', 'scala', 'kotlin', 'swift', 'groovy', 'powershell',
                'ini', 'toml', 'nginx', 'apache', 'diff', 'plaintext', 'text', 'console', 'log'];
            if (knownLanguages.includes(cls.toLowerCase())) {
                language = cls;
                break;
            }
        }
        
        // Skip mermaid diagrams - they get converted to SVG visualizations
        if (language && language.toLowerCase() !== 'mermaid') {
            const pre = codeBlock.parentElement;
            if (pre && pre.tagName === 'PRE' && !pre.parentElement.classList.contains('code-block-wrapper')) {
                // Create wrapper div
                const wrapper = document.createElement('div');
                wrapper.className = 'code-block-wrapper';
                wrapper.style.cssText = 'position: relative; margin-top: 1.5em;';
                
                // Create the badge as a tab above the code block
                const badge = document.createElement('span');
                badge.className = 'code-language-badge';
                badge.textContent = language.toUpperCase();
                //badge.style.cssText = 'position: absolute; top: -1.5em; right: 0; ' +
                //    'background-color: #2d2d2d; color: #e6db74; ' +
                //    'padding: 4px 12px; border-radius: 4px 4px 0 0; font-size: 0.75em; ' +
                //    'font-family: sans-serif; text-transform: uppercase; letter-spacing: 0.5px; ' +
                //    'font-weight: 600; z-index: 1;';
                
                // Wrap the pre element
                pre.parentNode.insertBefore(wrapper, pre);
                wrapper.appendChild(badge);
                wrapper.appendChild(pre);
                
                // Remove top border-radius from pre on the right side
                pre.style.borderTopRightRadius = '0';
            }
        }
    });
})();
</script>

<!-- Scroll Reveal Animation for Article Cards -->
<script>
(function() {
    var revealElements = document.querySelectorAll('.scroll-reveal');
    
    if (revealElements.length === 0) return;
    
    // Check if user prefers reduced motion - just mark as revealed
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        revealElements.forEach(function(el) { el.classList.add('revealed'); });
        return;
    }
    
    // Enable JS-based animation
    document.body.classList.add('js-ready');
    
    // Immediately reveal items that are visible on page load (above the fold)
    var viewportHeight = window.innerHeight;
    revealElements.forEach(function(el) {
        var rect = el.getBoundingClientRect();
        if (rect.top < viewportHeight) {
            // Small delay for staggered effect
            setTimeout(function() {
                el.classList.add('revealed');
            }, 50);
        }
    });
    
    // Use Intersection Observer for items below the fold
    var observerOptions = {
        root: null,
        rootMargin: '0px 0px -30px 0px',
        threshold: 0.1
    };
    
    var revealObserver = new IntersectionObserver(function(entries, observer) {
        entries.forEach(function(entry) {
            if (entry.isIntersecting) {
                entry.target.classList.add('revealed');
                observer.unobserve(entry.target);
            }
        });
    }, observerOptions);
    
    revealElements.forEach(function(el) {
        if (!el.classList.contains('revealed')) {
            revealObserver.observe(el);
        }
    });
})();
</script>
